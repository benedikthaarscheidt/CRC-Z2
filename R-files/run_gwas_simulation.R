# Script: run_gwas_simulation.R
# Purpose: Load pre-generated genetics, phenotypes, and scores from head3.R output
#          and run GWAS to identify causal SNPs

library(dplyr)

# -----------------------------------------------------------------------------
# 1. Configuration
# -----------------------------------------------------------------------------
USE_KINSHIP <- FALSE # Use Mixed Linear Model with Kinship matrix
KEEP_REPLICATES <<- TRUE # Use all 3 replicates per genotype

# -----------------------------------------------------------------------------
# 2. Load Data from Latest head3.R Run
# -----------------------------------------------------------------------------
message("Step 1: Loading Data from head3.R Output...")
scores_base_dir <- "~/CRC_1644_Z2/synthetic_data/scores_output"

# Find all run directories
run_dirs <- list.dirs(scores_base_dir, full.names = TRUE, recursive = FALSE)
run_dirs <- run_dirs[grepl("run_", basename(run_dirs))]

if (length(run_dirs) == 0) {
  stop(
    "No run directories found in: ", scores_base_dir,
    "\nPlease run head3.R first to generate the data."
  )
}

# Get the most recent one
latest_run <- run_dirs[which.max(file.info(run_dirs)$mtime)]
message("Loading data from: ", latest_run)

# Load all necessary data
scores_list <- readRDS(file.path(latest_run, "scores_list.rds"))
snp_matrix <- readRDS(file.path(latest_run, "snp_matrix.rds"))
kinship_matrix <- readRDS(file.path(latest_run, "kinship_matrix.rds"))
params_df <- read.csv(file.path(latest_run, "genotypic_parameters.csv"))
truth_df <- read.csv(file.path(latest_run, "causal_snps_truth.csv"))

message("Loaded:")
message("  - ", length(scores_list), " plasticity scores")
message("  - ", nrow(snp_matrix), " genotypes × ", ncol(snp_matrix), " SNPs")
message("  - Kinship matrix: ", nrow(kinship_matrix), "×", ncol(kinship_matrix))

# -----------------------------------------------------------------------------
# 3. Prepare Data for GWAS
# -----------------------------------------------------------------------------
message("Step 2: Preparing Data for GWAS...")

if (!requireNamespace("sommer", quietly = TRUE)) {
  stop("Package 'sommer' is required. Please install it: install.packages('sommer')")
}
library(sommer)

# SNP matrix and Kinship matrix already loaded from run directory
snp_matrix <- as.matrix(snp_matrix)

# Use the Kinship matrix if specified
# Use the Kinship matrix if specified
K <- NULL
if (USE_KINSHIP) {
  K <- kinship_matrix
  message("Using loaded Kinship matrix")
} else {
  message("Running Standard GWAS (No Kinship)")
}

# -----------------------------------------------------------------------------
# 4. Run GWAS Loop
# -----------------------------------------------------------------------------
message(paste("Step 4: Running GWAS (Kinship =", USE_KINSHIP, ")..."))

# List of scores to test
# We use the full list generated by head3.R
# We use the full list generated by head3.R
target_scores <- scores_list

all_gwas_results <- list()

for (score_name in names(target_scores)) {
  score_data <- target_scores[[score_name]]

  # Convert matrix-like structure to proper dataframe
  if (!is.data.frame(score_data)) {
    score_df <- as.data.frame(score_data, stringsAsFactors = FALSE)
  } else {
    score_df <- score_data
  }

  message(paste("\n=== Processing score:", score_name, "==="))
  message(paste("  Rows:", nrow(score_df), "| Columns:", paste(colnames(score_df), collapse = ", ")))

  # Get unique types
  if (!"Type" %in% colnames(score_df)) {
    warning(paste("No Type column in", score_name, "- skipping"))
    next
  }

  types <- unique(score_df$Type)
  message(paste("  Types:", paste(types, collapse = ", ")))

  for (type in types) {
    message(paste("    Running GWAS for:", type))

    # Subset by type
    sub_df <- score_df[score_df$Type == type, , drop = FALSE]

    # Extract genotype IDs
    if ("Genotype_ID" %in% colnames(sub_df)) {
      geno_ids <- sub_df$Genotype_ID
    } else {
      geno_ids <- rownames(sub_df)
    }

    # Remove replicate suffix
    clean_ids <- sub("_Rep_.*", "", geno_ids)
    # Add "Genotype_" prefix if missing
    if (!any(grepl("Genotype", clean_ids))) {
      clean_ids <- paste0("Genotype_", clean_ids)
    }

    # Create phenotype dataframe
    pheno <- data.frame(
      id = clean_ids,
      y = as.numeric(sub_df$Score),
      stringsAsFactors = FALSE
    )

    # Filter to match SNP matrix rows
    pheno <- pheno[pheno$id %in% rownames(snp_matrix), ]

    message(paste("      Phenotypes after filtering:", nrow(pheno)))

    if (nrow(pheno) == 0) {
      warning(paste("      No matching genotypes for", score_name, type))
      next
    }

    # Run GWAS using rrBLUP
    # This handles Kinship matrix (population structure) correctly

    if (USE_KINSHIP) {
      if (!requireNamespace("rrBLUP", quietly = TRUE)) {
        stop("Package 'rrBLUP' is required. Please install it.")
      }
      library(rrBLUP)

      message(paste("      Running GWAS on", ncol(snp_matrix), "SNPs using rrBLUP with Kinship..."))

      # Prepare Genotype Data for rrBLUP
      rng <- range(snp_matrix, na.rm = TRUE)
      if (rng[1] >= 0 && rng[2] <= 2) {
        snp_coded <- t(snp_matrix - 1)
      } else {
        snp_coded <- t(snp_matrix)
      }

      geno_df <- data.frame(
        name = colnames(snp_matrix),
        chrom = 1,
        pos = 1:ncol(snp_matrix),
        stringsAsFactors = FALSE
      )
      geno_df <- cbind(geno_df, snp_coded)

      pheno_rr <- pheno[, c("id", "y")]
      colnames(pheno_rr) <- c("line", "y")

      # Run GWAS with Kinship
      ans <- GWAS(pheno_rr, geno_df, K = K, min.MAF = 0, n.PC = 0, P3D = TRUE, plot = FALSE)

      # Extract scores
      score_col <- "y"
      if (!score_col %in% colnames(ans)) {
        score_col <- colnames(ans)[ncol(ans)]
      }
      p_values <- 10^(-ans[[score_col]])

      res_df <- data.frame(
        SNP = ans$name,
        P_Value = p_values,
        Score = score_name,
        Type = type,
        LogP = ans[[score_col]],
        stringsAsFactors = FALSE
      )
    } else {
      # Simple Linear Model (No Kinship)
      message(paste("      Running Standard GWAS (LM) on", ncol(snp_matrix), "SNPs..."))

      # Align phenotypes with genotypes
      # pheno$id matches rownames(snp_matrix)
      common_ids <- intersect(pheno$id, rownames(snp_matrix))
      pheno_sub <- pheno[match(common_ids, pheno$id), ]
      geno_sub <- snp_matrix[match(common_ids, rownames(snp_matrix)), , drop = FALSE]

      y <- pheno_sub$y

      # Filter out NA/NaN/Inf in y
      valid_idx <- which(is.finite(y))
      if (length(valid_idx) < length(y)) {
        message(paste("        Removed", length(y) - length(valid_idx), "individuals with invalid phenotypes."))
        y <- y[valid_idx]
        geno_sub <- geno_sub[valid_idx, , drop = FALSE]
      }

      if (length(y) < 3) {
        warning(paste("      Skipping", score_name, type, "- not enough valid phenotypes (n < 3)."))
        next
      }

      n_snps <- ncol(geno_sub)
      p_values <- numeric(n_snps)

      # Fast loop for LM
      for (i in 1:n_snps) {
        # Simple regression: y ~ SNP
        # We assume additive model (0, 1, 2)
        fit <- lm(y ~ geno_sub[, i])
        # Extract P-value for the SNP term (2nd coefficient)
        summ <- summary(fit)
        if (nrow(summ$coefficients) > 1) {
          p_values[i] <- summ$coefficients[2, 4]
        } else {
          p_values[i] <- 1.0 # No variation or perfect fit issues
        }
      }

      res_df <- data.frame(
        SNP = colnames(snp_matrix),
        P_Value = p_values,
        Score = score_name,
        Type = type,
        LogP = -log10(p_values),
        stringsAsFactors = FALSE
      )
    }

    # Remove NAs
    res_df <- res_df[!is.na(res_df$P_Value), ]

    # Apply Bonferroni correction
    res_df$P_Adj <- p.adjust(res_df$P_Value, method = "bonferroni")

    n_sig <- sum(res_df$P_Adj < 0.05)
    message(paste("      Significant hits (Bonferroni < 0.05):", n_sig))

    all_gwas_results[[paste(score_name, type, sep = "_")]] <- res_df
  }
}

if (length(all_gwas_results) == 0) {
  stop("No GWAS results generated! Check that scores have valid Type column and match SNP matrix.")
}

final_results <- do.call(rbind, all_gwas_results)

# Manhattan Plot
library(ggplot2)

message("Step 5: Saving Results...")
outfile <- if (USE_KINSHIP) "gwas_results_mlm_80.csv" else "gwas_results_lm_80.csv"
write.csv(final_results, file.path(latest_run, outfile), row.names = FALSE)

# Prepare data for plotting
message("Preparing Manhattan plots...")
message(paste("final_results class:", class(final_results)))
message(paste("final_results dimensions:", paste(dim(final_results), collapse = " x ")))

# Ensure itHans data frame
if (!is.data.frame(final_results)) {
  final_results <- as.data.frame(final_results)
}

final_results$Pos <- as.numeric(gsub("SNP_", "", final_results$SNP))

# Filter out invalid values
final_results <- final_results[complete.cases(final_results[, c("LogP", "Pos")]), ]
valid_data <- subset(final_results, is.finite(LogP) & is.finite(Pos))

message(paste("Valid data points:", nrow(valid_data), "of", nrow(final_results)))

if (nrow(valid_data) == 0) {
  warning("No valid data points for Manhattan plot!")
} else {
  plotfile <- if (USE_KINSHIP) "gwas_manhattan_mlm_80.pdf" else "gwas_manhattan_lm_80.pdf"

  pdf(file.path(latest_run, plotfile), width = 12, height = 8)

  scores <- unique(valid_data$Score)
  bonferroni_threshold <- -log10(0.05 / ncol(snp_matrix))

  for (s in scores) {
    score_data <- valid_data[valid_data$Score == s, ]

    if (nrow(score_data) > 0) {
      message(paste("Plotting", s, "-", nrow(score_data), "points"))

      p <- ggplot(score_data, aes(x = Pos, y = LogP, color = Type)) +
        geom_point(alpha = 0.6, size = 1) +
        geom_hline(
          yintercept = bonferroni_threshold,
          color = "red", linetype = "dashed", linewidth = 0.5
        ) +
        facet_wrap(~Type, ncol = 1, scales = "free_y") +
        labs(
          title = paste("GWAS Manhattan Plot:", s),
          subtitle = paste("Kinship =", USE_KINSHIP),
          x = "SNP Position",
          y = "-log10(P-value)"
        ) +
        theme_bw() +
        theme(legend.position = "none")

      print(p)
    } else {
      message(paste("Skipping", s, "- no valid data"))
    }
  }

  dev.off()
  message(paste("Manhattan plots saved to:", file.path(latest_run, plotfile)))
}
