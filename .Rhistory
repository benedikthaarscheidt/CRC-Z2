union = length(union(a, b))  # Corrected union calculation
jaccard_index = intersection / union
return (1 - jaccard_index)  # Jaccard distance
}
print(jaccard(a,a))
toy_matrix <- matrix(c(1, 2, 3, 4, 5, 6, 7, 8, 9), nrow = 3, ncol = 3)
print(toy_matrix)
print(eigen(toy_matrix))
adj_matrix <- matrix(c(
0, 1, 0, -1,
-1, 0, 1, 0,
0,- 1, 0, 1,
1, 0, -1, 0
), nrow = 4, ncol = 4, byrow = TRUE)
print(eigen(adj_matrix))
#plot(graph_from_adjacency_matrix(adj_matrix), directed=FALSE)
g=graph_from_atlas(500)
plot(g)
d=as_adjacency_matrix(g)
print(d)
lap=diag(degree(g))-d
print(eigen(lap))
eigen(matrix(1,4,4))
# Define the adjacency matrix A
A <- matrix(c(0, 1, 0,
1, 0, 1,
0, 1, 0), nrow = 3, byrow = TRUE)
a=graph_from_adjacency_matrix(A)
# Define the degree matrix D
D <- diag(rowSums(A))
# Compute the Laplacian matrix L
L <- D - A
# Print the matrices
print("Adjacency matrix A:")
print(A)
print("Degree matrix D:")
print(D)
print("Laplacian matrix L:")
print(L)
# Compute eigenvalues and eigenvectors of L
eig <- eigen(L)
eigenvalues <- eig$values
eigenvectors <- eig$vectors
print("Eigenvalues of L:")
print(eigenvalues)
print("Eigenvectors of L:")
print(eigenvectors)
print(eigen(laplacian_matrix(a)))
library(igraph)
# Function to compute the modular product of two graphs
# Function to compute the modular product of two graphs
modular_product <- function(G1, G2) {
# Get vertex and edge lists
V1 <- V(G1)
V2 <- V(G2)
E1 <- as_edgelist(G1)
E2 <- as_edgelist(G2)
# Create an empty graph for the modular product
product_graph <- graph.empty(n = length(V1) * length(V2), directed = FALSE)
# Name the vertices as pairs
vertex_names <- c()
for (v1 in 1:length(V1)) {
for (v2 in 1:length(V2)) {
vertex_names <- c(vertex_names, paste(v1, v2, sep = "-"))
}
}
V(product_graph)$name <- vertex_names
# Add edges to the product graph
for (e1 in 1:nrow(E1)) {
for (e2 in 1:nrow(E2)) {
u1 <- E1[e1, 1]
v1 <- E1[e1, 2]
u2 <- E2[e2, 1]
v2 <- E2[e2, 2]
if (!is.na(u1) && !is.na(v1) && !is.na(u2) && !is.na(v2) && u1 != v1 && u2 != v2) {
product_graph <- add_edges(product_graph, c(
which(V(product_graph)$name == paste(u1, u2, sep = "-")),
which(V(product_graph)$name == paste(v1, v2, sep = "-"))
))
product_graph <- add_edges(product_graph, c(
which(V(product_graph)$name == paste(v1, u2, sep = "-")),
which(V(product_graph)$name == paste(u1, v2, sep = "-"))
))
}
}
}
return(product_graph)
}
adj_graph_1 <- matrix(c(0, 1, 1, 0), nrow = 2, byrow = TRUE)
G1=graph_from_adjacency_matrix(adj_graph_1)
plot(G1)
adj_graph_2=matrix(c(0,1,1,1,0,1,1,1,0),nrow=3,byrow=T)
G2=graph_from_adjacency_matrix(adj_graph_2)
plot(G2)
# Example usage
G_modular <- modular_product(G1, G2)
plot(G_modular)
################################ Bron_kerbosch
# Bron-Kerbosch algorithm with pivoting
bron_kerbosch2 <- function(R, P, X, graph) {
if (length(P) == 0 && length(X) == 0) {
print(R) # Report R as a maximal clique
return()
}
else {
union_PX <- union(P, X)
u <- sample(union_PX, 1)
}
# Iterate over each vertex v in P \ N(u)
for (v in setdiff(P, neighbors(graph, u))) {
neighbors_v <- neighbors(graph, v)
bron_kerbosch2(
R=union(R, v),
P=intersect(P, neighbors_v),
X=intersect(X, neighbors_v),
graph
)
P <- setdiff(P, v)
X <- union(X, v)
}
}
# Create an example graph
adj_matrix <- matrix(c(0, 1, 1, 0,
1, 0, 1, 0,
1, 1, 0, 1,
0, 0, 1, 0),
nrow = 4, byrow = TRUE)
graph <- graph_from_adjacency_matrix(adj_matrix, mode = "undirected")
plot(graph)
g=graph_from_atlas(401)
plot(g)
# Initial call
R <- c()
P <- V(g)
X <- c()
bron_kerbosch2(R, P, X, g)
###################################
transitivity2=function(graph){
A=as_adjacency_matrix(graph)
A3=A%*%A%*%A
triangles=sum(diag(A3))/6
K=degree(graph)
triplets=sum(K*(K-1)/2)
if(triplets == 0){
return(0)
}else{
return(3*triangles/triplets)
}
}
h=graph_from_atlas(250)
A <- matrix(c(0, 1, 1,
1, 0, 1,
1, 1, 0),
nrow = 3, byrow = TRUE)
# Create an undirected graph from the adjacency matrix
B <- graph_from_adjacency_matrix(A, mode = "undirected")
check=transitivity2(h)
print(check)
test=transitivity(h)
print(test)
A2=A%*%A
t=A * A2
print(t)
edgelist <- matrix(c(1, 2, 2, 3, 4, 5), ncol = 2, byrow = TRUE)
g=graph_from_edgelist(edgelist,directed=F)
plot(g)
print(eigen(g))
library(igraph)
a <- c(1, 2, 3, 4, 5)
jaccard <- function(a, b) {
intersection = length(intersect(a, b))
union = length(union(a, b))  # Corrected union calculation
jaccard_index = intersection / union
return (1 - jaccard_index)  # Jaccard distance
}
print(jaccard(a,a))
toy_matrix <- matrix(c(1, 2, 3, 4, 5, 6, 7, 8, 9), nrow = 3, ncol = 3)
print(toy_matrix)
print(eigen(toy_matrix))
adj_matrix <- matrix(c(
0, 1, 0, -1,
-1, 0, 1, 0,
0,- 1, 0, 1,
1, 0, -1, 0
), nrow = 4, ncol = 4, byrow = TRUE)
print(eigen(adj_matrix))
#plot(graph_from_adjacency_matrix(adj_matrix), directed=FALSE)
g=graph_from_atlas(500)
plot(g)
d=as_adjacency_matrix(g)
print(d)
lap=diag(degree(g))-d
print(eigen(lap))
eigen(matrix(1,4,4))
# Define the adjacency matrix A
A <- matrix(c(0, 1, 0,
1, 0, 1,
0, 1, 0), nrow = 3, byrow = TRUE)
a=graph_from_adjacency_matrix(A)
# Define the degree matrix D
D <- diag(rowSums(A))
# Compute the Laplacian matrix L
L <- D - A
# Print the matrices
print("Adjacency matrix A:")
print(A)
print("Degree matrix D:")
print(D)
print("Laplacian matrix L:")
print(L)
# Compute eigenvalues and eigenvectors of L
eig <- eigen(L)
eigenvalues <- eig$values
eigenvectors <- eig$vectors
print("Eigenvalues of L:")
print(eigenvalues)
print("Eigenvectors of L:")
print(eigenvectors)
print(eigen(laplacian_matrix(a)))
library(igraph)
# Function to compute the modular product of two graphs
# Function to compute the modular product of two graphs
modular_product <- function(G1, G2) {
# Get vertex and edge lists
V1 <- V(G1)
V2 <- V(G2)
E1 <- as_edgelist(G1)
E2 <- as_edgelist(G2)
# Create an empty graph for the modular product
product_graph <- graph.empty(n = length(V1) * length(V2), directed = FALSE)
# Name the vertices as pairs
vertex_names <- c()
for (v1 in 1:length(V1)) {
for (v2 in 1:length(V2)) {
vertex_names <- c(vertex_names, paste(v1, v2, sep = "-"))
}
}
V(product_graph)$name <- vertex_names
# Add edges to the product graph
for (e1 in 1:nrow(E1)) {
for (e2 in 1:nrow(E2)) {
u1 <- E1[e1, 1]
v1 <- E1[e1, 2]
u2 <- E2[e2, 1]
v2 <- E2[e2, 2]
if (!is.na(u1) && !is.na(v1) && !is.na(u2) && !is.na(v2) && u1 != v1 && u2 != v2) {
product_graph <- add_edges(product_graph, c(
which(V(product_graph)$name == paste(u1, u2, sep = "-")),
which(V(product_graph)$name == paste(v1, v2, sep = "-"))
))
product_graph <- add_edges(product_graph, c(
which(V(product_graph)$name == paste(v1, u2, sep = "-")),
which(V(product_graph)$name == paste(u1, v2, sep = "-"))
))
}
}
}
return(product_graph)
}
adj_graph_1 <- matrix(c(0, 1, 1, 0), nrow = 2, byrow = TRUE)
G1=graph_from_adjacency_matrix(adj_graph_1)
plot(G1)
adj_graph_2=matrix(c(0,1,1,1,0,1,1,1,0),nrow=3,byrow=T)
G2=graph_from_adjacency_matrix(adj_graph_2)
plot(G2)
# Example usage
G_modular <- modular_product(G1, G2)
plot(G_modular)
################################ Bron_kerbosch
# Bron-Kerbosch algorithm with pivoting
bron_kerbosch2 <- function(R, P, X, graph) {
if (length(P) == 0 && length(X) == 0) {
print(R) # Report R as a maximal clique
return()
}
else {
union_PX <- union(P, X)
u <- sample(union_PX, 1)
}
# Iterate over each vertex v in P \ N(u)
for (v in setdiff(P, neighbors(graph, u))) {
neighbors_v <- neighbors(graph, v)
bron_kerbosch2(
R=union(R, v),
P=intersect(P, neighbors_v),
X=intersect(X, neighbors_v),
graph
)
P <- setdiff(P, v)
X <- union(X, v)
}
}
# Create an example graph
adj_matrix <- matrix(c(0, 1, 1, 0,
1, 0, 1, 0,
1, 1, 0, 1,
0, 0, 1, 0),
nrow = 4, byrow = TRUE)
graph <- graph_from_adjacency_matrix(adj_matrix, mode = "undirected")
plot(graph)
g=graph_from_atlas(401)
plot(g)
# Initial call
R <- c()
P <- V(g)
X <- c()
bron_kerbosch2(R, P, X, g)
###################################
transitivity2=function(graph){
A=as_adjacency_matrix(graph)
A3=A%*%A%*%A
triangles=sum(diag(A3))/6
K=degree(graph)
triplets=sum(K*(K-1)/2)
if(triplets == 0){
return(0)
}else{
return(3*triangles/triplets)
}
}
h=graph_from_atlas(250)
A <- matrix(c(0, 1, 1,
1, 0, 1,
1, 1, 0),
nrow = 3, byrow = TRUE)
# Create an undirected graph from the adjacency matrix
B <- graph_from_adjacency_matrix(A, mode = "undirected")
check=transitivity2(h)
print(check)
test=transitivity(h)
print(test)
A2=A%*%A
t=A * A2
print(t)
edgelist <- matrix(c(1, 2, 2, 3, 4, 5), ncol = 2, byrow = TRUE)
g=graph_from_edgelist(edgelist,directed=F)
plot(g)
g1=as_adjacency_matrix(g)
eigen=eigen(g)
library(igraph)
a <- c(1, 2, 3, 4, 5)
jaccard <- function(a, b) {
intersection = length(intersect(a, b))
union = length(union(a, b))  # Corrected union calculation
jaccard_index = intersection / union
return (1 - jaccard_index)  # Jaccard distance
}
print(jaccard(a,a))
toy_matrix <- matrix(c(1, 2, 3, 4, 5, 6, 7, 8, 9), nrow = 3, ncol = 3)
print(toy_matrix)
print(eigen(toy_matrix))
adj_matrix <- matrix(c(
0, 1, 0, -1,
-1, 0, 1, 0,
0,- 1, 0, 1,
1, 0, -1, 0
), nrow = 4, ncol = 4, byrow = TRUE)
print(eigen(adj_matrix))
#plot(graph_from_adjacency_matrix(adj_matrix), directed=FALSE)
g=graph_from_atlas(500)
plot(g)
d=as_adjacency_matrix(g)
print(d)
lap=diag(degree(g))-d
print(eigen(lap))
eigen(matrix(1,4,4))
# Define the adjacency matrix A
A <- matrix(c(0, 1, 0,
1, 0, 1,
0, 1, 0), nrow = 3, byrow = TRUE)
a=graph_from_adjacency_matrix(A)
# Define the degree matrix D
D <- diag(rowSums(A))
# Compute the Laplacian matrix L
L <- D - A
# Print the matrices
print("Adjacency matrix A:")
print(A)
print("Degree matrix D:")
print(D)
print("Laplacian matrix L:")
print(L)
# Compute eigenvalues and eigenvectors of L
eig <- eigen(L)
eigenvalues <- eig$values
eigenvectors <- eig$vectors
print("Eigenvalues of L:")
print(eigenvalues)
print("Eigenvectors of L:")
print(eigenvectors)
print(eigen(laplacian_matrix(a)))
library(igraph)
# Function to compute the modular product of two graphs
# Function to compute the modular product of two graphs
modular_product <- function(G1, G2) {
# Get vertex and edge lists
V1 <- V(G1)
V2 <- V(G2)
E1 <- as_edgelist(G1)
E2 <- as_edgelist(G2)
# Create an empty graph for the modular product
product_graph <- graph.empty(n = length(V1) * length(V2), directed = FALSE)
# Name the vertices as pairs
vertex_names <- c()
for (v1 in 1:length(V1)) {
for (v2 in 1:length(V2)) {
vertex_names <- c(vertex_names, paste(v1, v2, sep = "-"))
}
}
V(product_graph)$name <- vertex_names
# Add edges to the product graph
for (e1 in 1:nrow(E1)) {
for (e2 in 1:nrow(E2)) {
u1 <- E1[e1, 1]
v1 <- E1[e1, 2]
u2 <- E2[e2, 1]
v2 <- E2[e2, 2]
if (!is.na(u1) && !is.na(v1) && !is.na(u2) && !is.na(v2) && u1 != v1 && u2 != v2) {
product_graph <- add_edges(product_graph, c(
which(V(product_graph)$name == paste(u1, u2, sep = "-")),
which(V(product_graph)$name == paste(v1, v2, sep = "-"))
))
product_graph <- add_edges(product_graph, c(
which(V(product_graph)$name == paste(v1, u2, sep = "-")),
which(V(product_graph)$name == paste(u1, v2, sep = "-"))
))
}
}
}
return(product_graph)
}
adj_graph_1 <- matrix(c(0, 1, 1, 0), nrow = 2, byrow = TRUE)
G1=graph_from_adjacency_matrix(adj_graph_1)
plot(G1)
adj_graph_2=matrix(c(0,1,1,1,0,1,1,1,0),nrow=3,byrow=T)
G2=graph_from_adjacency_matrix(adj_graph_2)
plot(G2)
# Example usage
G_modular <- modular_product(G1, G2)
plot(G_modular)
################################ Bron_kerbosch
# Bron-Kerbosch algorithm with pivoting
bron_kerbosch2 <- function(R, P, X, graph) {
if (length(P) == 0 && length(X) == 0) {
print(R) # Report R as a maximal clique
return()
}
else {
union_PX <- union(P, X)
u <- sample(union_PX, 1)
}
# Iterate over each vertex v in P \ N(u)
for (v in setdiff(P, neighbors(graph, u))) {
neighbors_v <- neighbors(graph, v)
bron_kerbosch2(
R=union(R, v),
P=intersect(P, neighbors_v),
X=intersect(X, neighbors_v),
graph
)
P <- setdiff(P, v)
X <- union(X, v)
}
}
# Create an example graph
adj_matrix <- matrix(c(0, 1, 1, 0,
1, 0, 1, 0,
1, 1, 0, 1,
0, 0, 1, 0),
nrow = 4, byrow = TRUE)
graph <- graph_from_adjacency_matrix(adj_matrix, mode = "undirected")
plot(graph)
g=graph_from_atlas(401)
plot(g)
# Initial call
R <- c()
P <- V(g)
X <- c()
bron_kerbosch2(R, P, X, g)
###################################
transitivity2=function(graph){
A=as_adjacency_matrix(graph)
A3=A%*%A%*%A
triangles=sum(diag(A3))/6
K=degree(graph)
triplets=sum(K*(K-1)/2)
if(triplets == 0){
return(0)
}else{
return(3*triangles/triplets)
}
}
h=graph_from_atlas(250)
A <- matrix(c(0, 1, 1,
1, 0, 1,
1, 1, 0),
nrow = 3, byrow = TRUE)
# Create an undirected graph from the adjacency matrix
B <- graph_from_adjacency_matrix(A, mode = "undirected")
check=transitivity2(h)
print(check)
test=transitivity(h)
print(test)
A2=A%*%A
t=A * A2
print(t)
edgelist <- matrix(c(1, 2, 2, 3, 4, 5), ncol = 2, byrow = TRUE)
g=graph_from_edgelist(edgelist,directed=F)
plot(g)
g1=as_adjacency_matrix(g)
eigen=eigen(g1)
print(eigen)
